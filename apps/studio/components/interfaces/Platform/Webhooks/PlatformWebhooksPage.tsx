import { useRouter } from 'next/router'
import { parseAsString, parseAsStringLiteral, useQueryState } from 'nuqs'
import { useEffect, useMemo, useState } from 'react'
import { toast } from 'sonner'

import { useParams } from 'common'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  Button,
  copyToClipboard,
} from 'ui'
import { PageContainer } from 'ui-patterns/PageContainer'
import { PageSection, PageSectionContent } from 'ui-patterns/PageSection'
import { PLATFORM_WEBHOOKS_MOCK_DATA } from './PlatformWebhooks.mock'
import { PlatformWebhooksDeliveryDetailsSheet } from './PlatformWebhooksDeliveryDetailsSheet'
import { PlatformWebhooksEndpointDetails } from './PlatformWebhooksEndpointDetails'
import { PlatformWebhooksEndpointList } from './PlatformWebhooksEndpointList'
import {
  EndpointFormValues,
  PlatformWebhooksEndpointSheet,
  toEndpointPayload,
} from './PlatformWebhooksEndpointSheet'
import { PlatformWebhooksHeader } from './PlatformWebhooksHeader'
import {
  filterWebhookDeliveries,
  filterWebhookEndpoints,
  usePlatformWebhooksMockStore,
} from './PlatformWebhooks.store'
import type { WebhookScope } from './PlatformWebhooks.types'

const PANEL_VALUES = ['create', 'edit'] as const

interface PlatformWebhooksPageProps {
  scope: WebhookScope
  endpointId?: string
}

export const PlatformWebhooksPage = ({ scope, endpointId }: PlatformWebhooksPageProps) => {
  const router = useRouter()
  const { slug, ref } = useParams()
  const {
    endpoints,
    deliveries,
    createEndpoint,
    updateEndpoint,
    deleteEndpoint,
    regenerateSecret,
  } = usePlatformWebhooksMockStore(scope)
  const [deliveryId, setDeliveryId] = useQueryState('deliveryId', parseAsString)
  const [panel, setPanel] = useQueryState('panel', parseAsStringLiteral(PANEL_VALUES))
  const [search, setSearch] = useQueryState(
    'search',
    parseAsString.withDefault('').withOptions({ history: 'replace', clearOnDefault: true })
  )
  const [deliverySearch, setDeliverySearch] = useQueryState(
    'deliverySearch',
    parseAsString.withDefault('').withOptions({ history: 'replace', clearOnDefault: true })
  )

  const [endpointIdPendingDelete, setEndpointIdPendingDelete] = useState<string | null>(null)
  const [showRegenerateSecretConfirm, setShowRegenerateSecretConfirm] = useState(false)
  const [editEnabledOverride, setEditEnabledOverride] = useState<boolean | null>(null)
  const [deliveryDetailsTab, setDeliveryDetailsTab] = useState<'event' | 'response'>('event')

  const scopeLabel = scope === 'organization' ? 'Organization Webhooks' : 'Project Webhooks'
  const scopeDescription =
    scope === 'organization'
      ? 'Organization-level webhook endpoints and deliveries'
      : 'Webhook endpoints scoped to this project'

  const eventTypeOptions = PLATFORM_WEBHOOKS_MOCK_DATA[scope].eventTypes
  const webhooksHref =
    scope === 'organization' ? `/org/${slug}/webhooks` : `/project/${ref}/settings/webhooks`

  const selectedEndpoint = useMemo(
    () => endpoints.find((endpoint) => endpoint.id === endpointId) ?? null,
    [endpoints, endpointId]
  )
  const isEndpointView = !!selectedEndpoint
  const headerTitle = isEndpointView ? 'Endpoint' : scopeLabel
  const headerDescription = isEndpointView ? selectedEndpoint?.url ?? '' : scopeDescription

  const endpointPendingDelete = useMemo(
    () => endpoints.find((endpoint) => endpoint.id === endpointIdPendingDelete) ?? null,
    [endpoints, endpointIdPendingDelete]
  )

  useEffect(() => {
    if (!!endpointId && !selectedEndpoint) {
      toast('Endpoint not found')
      router.replace(webhooksHref)
    }
  }, [endpointId, selectedEndpoint, router, webhooksHref])

  const filteredEndpoints = useMemo(() => {
    return filterWebhookEndpoints(endpoints, search)
  }, [endpoints, search])

  const filteredDeliveries = useMemo(() => {
    if (!selectedEndpoint) return []
    return filterWebhookDeliveries(deliveries, selectedEndpoint.id, deliverySearch)
  }, [deliveries, deliverySearch, selectedEndpoint])

  const selectedDelivery = useMemo(() => {
    if (!selectedEndpoint || !deliveryId) return null
    return (
      deliveries.find(
        (delivery) => delivery.id === deliveryId && delivery.endpointId === selectedEndpoint.id
      ) ?? null
    )
  }, [deliveries, deliveryId, selectedEndpoint])

  const deliveryAttempt = useMemo(() => {
    if (!selectedEndpoint || !selectedDelivery) return null
    const endpointDeliveries = deliveries
      .filter((delivery) => delivery.endpointId === selectedEndpoint.id)
      .sort((a, b) => new Date(b.attemptAt).getTime() - new Date(a.attemptAt).getTime())
    const index = endpointDeliveries.findIndex((delivery) => delivery.id === selectedDelivery.id)
    return index >= 0 ? index + 1 : null
  }, [deliveries, selectedDelivery, selectedEndpoint])

  const deliveryEventPayload = useMemo(() => {
    if (!selectedEndpoint || !selectedDelivery) return ''
    return JSON.stringify(
      {
        endpoint_id: selectedEndpoint.id,
        endpoint_url: selectedEndpoint.url,
        event_type: selectedDelivery.eventType,
        event_id: selectedDelivery.id,
        attempted_at: selectedDelivery.attemptAt,
        scope,
      },
      null,
      2
    )
  }, [scope, selectedDelivery, selectedEndpoint])

  const deliveryResponsePayload = useMemo(() => {
    if (!selectedEndpoint || !selectedDelivery) return ''
    return JSON.stringify(
      {
        endpoint_id: selectedEndpoint.id,
        delivery_id: selectedDelivery.id,
        status: selectedDelivery.status,
        response_code: selectedDelivery.responseCode ?? null,
      },
      null,
      2
    )
  }, [selectedDelivery, selectedEndpoint])

  const handleDeleteEndpoint = () => {
    if (!endpointPendingDelete) return
    deleteEndpoint(endpointPendingDelete.id)
    if (endpointPendingDelete.id === endpointId) {
      router.push(webhooksHref)
      setDeliverySearch('')
    }
    setEndpointIdPendingDelete(null)
    toast.success(`Deleted endpoint "${endpointPendingDelete.url}"`)
  }

  const handleUpsertEndpoint = (values: EndpointFormValues) => {
    if (panel === 'create') {
      const createdEndpointId = createEndpoint(toEndpointPayload(values))
      router.push(`${webhooksHref}/${encodeURIComponent(createdEndpointId)}`)
      setPanel(null)
      setEditEnabledOverride(null)
      toast.success('Endpoint created')
      return
    }

    if (panel === 'edit' && selectedEndpoint) {
      updateEndpoint(selectedEndpoint.id, toEndpointPayload(values))
      setPanel(null)
      setEditEnabledOverride(null)
      toast.success('Endpoint updated')
    }
  }

  const handleRegenerateSecret = () => {
    if (!selectedEndpoint) return
    regenerateSecret(selectedEndpoint.id)
    setShowRegenerateSecretConfirm(false)
    toast.success('Signing secret regenerated')
  }

  const handleCopy = (value: string, label: string) => {
    copyToClipboard(value)
    toast.success(`Copied ${label}`)
  }

  const isEndpointSheetOpen = panel === 'create' || (panel === 'edit' && !!selectedEndpoint)

  useEffect(() => {
    if (!selectedEndpoint && !!deliveryId) {
      setDeliveryId(null)
    }
  }, [deliveryId, selectedEndpoint, setDeliveryId])

  useEffect(() => {
    if (!!deliveryId && !selectedDelivery) {
      setDeliveryId(null)
    }
  }, [deliveryId, selectedDelivery, setDeliveryId])

  return (
    <>
      <PlatformWebhooksHeader
        hasSelectedEndpoint={!!selectedEndpoint}
        headerTitle={headerTitle}
        headerDescription={headerDescription}
        endpointStatus={
          selectedEndpoint ? (selectedEndpoint.enabled ? 'enabled' : 'disabled') : undefined
        }
        endpointActions={
          selectedEndpoint ? (
            <>
              <Button
                type="default"
                onClick={() => {
                  setEditEnabledOverride(null)
                  setPanel('edit')
                }}
              >
                Edit
              </Button>
              <Button type="danger" onClick={() => setEndpointIdPendingDelete(selectedEndpoint.id)}>
                Delete
              </Button>
            </>
          ) : undefined
        }
        webhooksHref={webhooksHref}
        scopeLabel={scopeLabel}
      />

      <PageContainer size="default">
        <PageSection>
          <PageSectionContent>
            {!selectedEndpoint ? (
              <PlatformWebhooksEndpointList
                filteredEndpoints={filteredEndpoints}
                search={search}
                webhooksHref={webhooksHref}
                onCreateEndpoint={() => setPanel('create')}
                onDeleteEndpoint={(id) => setEndpointIdPendingDelete(id)}
                onSearchChange={setSearch}
                onViewEndpoint={(id) => {
                  router.push(`${webhooksHref}/${encodeURIComponent(id)}`)
                  setPanel(null)
                }}
              />
            ) : (
              <PlatformWebhooksEndpointDetails
                deliverySearch={deliverySearch}
                filteredDeliveries={filteredDeliveries}
                selectedEndpoint={selectedEndpoint}
                onDeliverySearchChange={setDeliverySearch}
                onOpenDelivery={(id) => {
                  setDeliveryDetailsTab('event')
                  setDeliveryId(id)
                }}
                onCopySecret={() => handleCopy(selectedEndpoint.signingSecret, 'signing secret')}
                onRegenerateSecret={() => setShowRegenerateSecretConfirm(true)}
              />
            )}
          </PageSectionContent>
        </PageSection>
      </PageContainer>

      <PlatformWebhooksDeliveryDetailsSheet
        deliveryAttempt={deliveryAttempt}
        deliveryDetailsTab={deliveryDetailsTab}
        deliveryEventPayload={deliveryEventPayload}
        deliveryResponsePayload={deliveryResponsePayload}
        open={!!selectedDelivery}
        selectedDelivery={selectedDelivery}
        onCopy={handleCopy}
        onOpenChange={(open) => !open && setDeliveryId(null)}
        onTabChange={setDeliveryDetailsTab}
      />

      <PlatformWebhooksEndpointSheet
        visible={isEndpointSheetOpen}
        mode={panel === 'create' ? 'create' : 'edit'}
        endpoint={panel === 'edit' ? selectedEndpoint ?? undefined : undefined}
        enabledOverride={panel === 'edit' ? editEnabledOverride : null}
        eventTypes={eventTypeOptions}
        onClose={() => {
          setPanel(null)
          setEditEnabledOverride(null)
        }}
        onSubmit={handleUpsertEndpoint}
      />

      <AlertDialog
        open={!!endpointPendingDelete}
        onOpenChange={(open) => !open && setEndpointIdPendingDelete(null)}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete endpoint</AlertDialogTitle>
            <AlertDialogDescription>
              {endpointPendingDelete
                ? `This will delete endpoint ${endpointPendingDelete.url}. This action cannot be undone.`
                : 'This action cannot be undone.'}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction variant="danger" onClick={handleDeleteEndpoint}>
              Delete endpoint
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      <AlertDialog open={showRegenerateSecretConfirm} onOpenChange={setShowRegenerateSecretConfirm}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Regenerate signing secret</AlertDialogTitle>
            <AlertDialogDescription>
              This will rotate the current signing secret used for webhook signature verification.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction variant="warning" onClick={handleRegenerateSecret}>
              Regenerate secret
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  )
}
