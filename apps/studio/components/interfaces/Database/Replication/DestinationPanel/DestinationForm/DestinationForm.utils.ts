import { UseMutateAsyncFunction } from '@tanstack/react-query'
import { snakeCase } from 'lodash'
import z from 'zod'

import { DestinationType } from '../DestinationPanel.types'
import { CREATE_NEW_KEY, CREATE_NEW_NAMESPACE } from './DestinationForm.constants'
import { DestinationPanelFormSchema } from './DestinationForm.schema'
import {
  BigQueryDestinationConfig,
  DestinationConfig,
  IcebergDestinationConfig,
} from '@/data/replication/create-destination-pipeline-mutation'
import {
  type CreateS3AccessKeyCredentialVariables,
  type S3AccessKeyCreateData,
} from '@/data/storage/s3-access-key-create-mutation'
import { ResponseError } from '@/types'

// Helper function to build destination config for validation
export const buildDestinationConfigForValidation = ({
  projectRef,
  selectedType,
  data,
}: {
  projectRef?: string
  selectedType: DestinationType
  data: z.infer<typeof DestinationPanelFormSchema>
}) => {
  if (!projectRef) throw new Error('Project ref is required')

  if (selectedType === 'BigQuery') {
    return {
      bigQuery: {
        projectId: data.projectId ?? '',
        datasetId: data.datasetId ?? '',
        serviceAccountKey: data.serviceAccountKey ?? '',
        connectionPoolSize: data.connectionPoolSize,
        maxStalenessMins: data.maxStalenessMins,
      },
    }
  } else if (selectedType === 'Analytics Bucket') {
    // For validation, use the namespace as-is (even if it's CREATE_NEW_NAMESPACE)
    // The actual creation will happen later in submitPipeline
    const validationNamespace =
      data.namespace === CREATE_NEW_NAMESPACE ? data.newNamespaceName : data.namespace

    // For validation purposes, if CREATE_NEW_KEY is selected, we skip S3 key validation
    // The actual key creation will happen later in submitPipeline
    // We'll use placeholder values for validation
    const s3Keys =
      data.s3AccessKeyId === CREATE_NEW_KEY
        ? { accessKey: 'placeholder', secretKey: 'placeholder' }
        : { accessKey: data.s3AccessKeyId ?? '', secretKey: data.s3SecretAccessKey ?? '' }

    return {
      iceberg: {
        projectRef,
        warehouseName: data.warehouseName ?? '',
        namespace: validationNamespace,
        catalogToken: data.catalogToken ?? '',
        s3AccessKeyId: s3Keys.accessKey,
        s3SecretAccessKey: s3Keys.secretKey,
        s3Region: data.s3Region ?? '',
      },
    }
  } else {
    throw new Error('Invalid destination type')
  }
}

export const buildDestinationConfig = async ({
  projectRef,
  selectedType,
  data,
  warehouseName,
  createS3AccessKey,
  resolveNamespace,
}: {
  projectRef?: string
  selectedType: DestinationType
  data: z.infer<typeof DestinationPanelFormSchema>
  warehouseName?: string
  createS3AccessKey: UseMutateAsyncFunction<
    S3AccessKeyCreateData,
    ResponseError,
    CreateS3AccessKeyCredentialVariables,
    unknown
  >
  resolveNamespace: (
    data: z.infer<typeof DestinationPanelFormSchema>
  ) => Promise<string | undefined>
}) => {
  if (!projectRef) throw new Error('Project ref is required')

  let destinationConfig: DestinationConfig | undefined = undefined

  if (selectedType === 'BigQuery') {
    const bigQueryConfig: BigQueryDestinationConfig = {
      projectId: data.projectId ?? '',
      datasetId: data.datasetId ?? '',
      serviceAccountKey: data.serviceAccountKey ?? '',
      connectionPoolSize: data.connectionPoolSize,
      maxStalenessMins: data.maxStalenessMins,
    }
    destinationConfig = { bigQuery: bigQueryConfig }
  } else if (selectedType === 'Analytics Bucket') {
    let s3Keys = { accessKey: data.s3AccessKeyId, secretKey: data.s3SecretAccessKey }

    if (data.s3AccessKeyId === CREATE_NEW_KEY) {
      const newKeys = await createS3AccessKey({
        projectRef,
        description: `Autogenerated key for replication to ${snakeCase(warehouseName)}`,
      })
      s3Keys = { accessKey: newKeys.access_key, secretKey: newKeys.secret_key }
    }

    // Resolve namespace (create if needed)
    const finalNamespace = await resolveNamespace(data)

    const icebergConfig: IcebergDestinationConfig = {
      projectRef: projectRef,
      warehouseName: data.warehouseName ?? '',
      namespace: finalNamespace,
      catalogToken: data.catalogToken ?? '',
      s3AccessKeyId: s3Keys.accessKey ?? '',
      s3SecretAccessKey: s3Keys.secretKey ?? '',
      s3Region: data.s3Region ?? '',
    }
    destinationConfig = { iceberg: icebergConfig }
  }

  return destinationConfig
}
